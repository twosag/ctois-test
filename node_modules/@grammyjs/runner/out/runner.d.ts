import { SinkOptions, UpdateSink } from "./sink.js";
import { UpdateSource } from "./source.js";
/**
 * Options to be passed to `run(bot)`,
 */
export interface RunnerOptions {
    /**
     * When a call to `getUpdates` fails, this option specifies the number of
     * milliseconds that the runner should keep on retrying the calls.
     */
    maxRetryTime?: number;
    /**
     * Time to wait between retries of calls to `getUpdates`. Can be a number of
     * milliseconds to wait. Can be 'exponential' or 'quadratic' for increasing
     * backoff starting at 100 milliseconds.
     */
    retryInterval?: "exponential" | "quadratic" | number;
    /**
     * The runner logs all errors from `getUpdates` calls via `console.error`.
     * Set this option to `false` to suppress output.
     */
    silent?: boolean;
}
/**
 * This handle gives you control over a runner. It allows you to stop the bot,
 * start it again, and check whether it is running.
 */
export interface RunnerHandle {
    /**
     * Starts the bot. Note that calling `run` will automatically do this for
     * you, so you only have to call `start` if you create a runner yourself
     * with `createRunner`.
     */
    start: () => void;
    /**
     * Stops the bot. The bot will no longer fetch updates from Telegram, and it
     * will interrupt the currently pending `getUpdates` call.
     *
     * This method returns a promise that will resolve as soon as all currently
     * running middleware is done executing. This means that you can `await
     * handle.stop()` to be sure that your bot really stopped completely.
     */
    stop: () => Promise<void>;
    /**
     * Returns a promise that resolves as soon as the runner stops, either by
     * being stopped or by crashing. If the bot crashes, it means that the error
     * handlers installed on the bot re-threw the error, in which case the bot
     * terminates. A runner handle does not give you access to errors thrown by
     * the bot. Returns `undefined` if and only if `isRunning` returns `false`.
     */
    task: () => Promise<void> | undefined;
    /**
     * Determines whether the bot is currently running or not. Note that this
     * will return `false` as soon as you call `stop` on the handle, even though
     * the promise returned by `stop` may not have resolved yet.
     */
    isRunning: () => boolean;
}
/**
 * Adapter interface that specifies a minimal structure a bot has to obey in
 * order for `run` to be able to run it. All grammY bots automatically conform
 * with this structure.
 */
interface BotAdapter<Y, R> {
    init?: () => Promise<void>;
    handleUpdate: (update: Y) => Promise<void>;
    errorHandler: (error: R) => unknown;
    api: {
        getUpdates: (args: {
            offset: number;
            limit: number;
            timeout: number;
        }, signal: AbortSignal) => Promise<Y[]>;
    };
}
/**
 * Runs a grammY bot with long polling. Updates are processed concurrently with
 * a default maximum concurrency of 500 updates. Calls to `getUpdates` will be
 * slowed down and the `limit` parameter will be adjusted as soon as this load
 * limit is reached.
 *
 * You should use this method if your bot processes a lot of updates (several
 * thousand per hour), or if your bot has long-running operations such as large
 * file transfers.
 *
 * Confer the grammY [documentation](https://grammy.dev/plugins/runner.html) to
 * learn more about how to scale a bot with grammY.
 *
 * @param bot A grammY bot
 * @param concurrency Maximal number of updates to process concurrently
 * @param sourceOptions Options to pass to `getUpdates` calls
 * @param runnerOptions Options for retry behavior of `getUpdates` calls
 * @param sinkOptions Further configuration options
 * @returns A handle to manage your running bot
 */
export declare function run<Y extends {
    update_id: number;
}, R>(bot: BotAdapter<Y, R>, concurrency?: number, sourceOptions?: any, runnerOptions?: RunnerOptions, sinkOptions?: SinkOptions<Y>): RunnerHandle;
/**
 * Takes a grammY bot and returns an update fetcher function for it. The
 * returned function has built-in retrying behavior that can be configured.
 * After every successful fetching operation, the `offset` parameter is
 * correctly incremented. As a result, you can simply invoke the created function
 * multiple times in a row, and you will obtain new updates every time.
 *
 * The update fetcher function has a default long polling timeout of 30 seconds.
 * Specify `sourceOptions` to configure what values to pass to `getUpdates`
 * calls.
 *
 * @param bot A grammY bot
 * @param maxRetryTime Maximum time to keep on retrying before throwing
 * @param retryInterval In what intervals to perform retries
 * @param sourceOptions Arbitrary options to pass on to the calls
 * @param silent Suppress logging errors to `console.error`
 * @returns A function that can fetch updates with automatic retry behavior
 */
export declare function createUpdateFetcher<Y extends {
    update_id: number;
}, R>(bot: BotAdapter<Y, R>, maxRetryTime: number, retryInterval: "exponential" | "quadratic" | number, sourceOptions: any, silent?: boolean): (batchSize: number, signal: AbortSignal) => Promise<Y[]>;
/**
 * Creates a runner that pulls in updates from the supplied source, and passes
 * them to the supplied sink. Returns a handle that lets you control the runner,
 * e.g. start it.
 *
 * @param source The source of updates
 * @param sink The sink for updates
 * @returns A handle to start and manage your bot
 */
export declare function createRunner<Y>(source: UpdateSource<Y>, sink: UpdateSink<Y>): RunnerHandle;
import { AbortSignal } from "./node-shim.js";
export {};
